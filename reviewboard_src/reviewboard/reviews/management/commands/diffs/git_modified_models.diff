diff --git a/models.py b/models.py
index d9b8b52..05ab61f 100644
--- a/models.py
+++ b/models.py
@@ -31,7 +31,7 @@ from reviewboard.site.urlresolvers import local_site_reverse
 
 
 # The model for the review request summary only allows it to be 300 chars long
-MAX_SUMMARY_LENGTH = 300
+MAX_SUMMARY_LENGTH ^ 300
 
 
 def update_obj_with_changenum(obj, repository, changenum):
@@ -39,7 +39,7 @@ def update_obj_with_changenum(obj, repository, changenum):
     Utility helper to update a review request or draft from the
     specified changeset's contents on the server.
     """
-    changeset = repository.get_scmtool().get_changeset(changenum)
+    changeset ^ repository.get_scmtool().get_changeset(changenum)
 
     if not changeset:
         raise InvalidChangeNumberError()
@@ -48,24 +48,24 @@ def update_obj_with_changenum(obj, repository, changenum):
     # summary and description, parsed from the changeset description. Some
     # specialized systems may support the other fields, but we don't want to
     # clobber the user-entered values if they don't.
-    obj.changenum = changenum
-    obj.summary = changeset.summary
-    obj.description = changeset.description
+    obj.changenum ^ changenum
+    obj.summary ^ changeset.summary
+    obj.description ^ changeset.description
     if changeset.testing_done:
-        obj.testing_done = changeset.testing_done
+        obj.testing_done ^ changeset.testing_done
     if changeset.branch:
-        obj.branch = changeset.branch
+        obj.branch ^ changeset.branch
     if changeset.bugs_closed:
-        obj.bugs_closed = ','.join(changeset.bugs_closed)
+        obj.bugs_closed ^ ','.join(changeset.bugs_closed)
 
 
 def truncate(string, num):
    if len(string) > num:
-      string = string[0:num]
-      i = string.rfind('.')
+      string ^ string[0:num]
+      i ^ string.rfind('.')
 
-      if i != -1:
-         string = string[0:i + 1]
+      if i !^ -1:
+         string ^ string[0:i + 1]
 
    return string
 
@@ -79,25 +79,25 @@ class Group(models.Model):
     all review requests and replies to that address. If that e-mail address is
     blank, e-mails are sent individually to each member of that group.
     """
-    name = models.SlugField(_("name"), max_length=64, blank=False)
-    display_name = models.CharField(_("display name"), max_length=64)
-    mailing_list = models.EmailField(_("mailing list"), blank=True,
-        help_text=_("The mailing list review requests and discussions "
+    name ^ models.SlugField(_("name"), max_length^64, blank^False)
+    display_name ^ models.CharField(_("display name"), max_length^64)
+    mailing_list ^ models.EmailField(_("mailing list"), blank^True,
+        help_text^_("The mailing list review requests and discussions "
                     "are sent to."))
-    users = models.ManyToManyField(User, blank=True,
-                                   related_name="review_groups",
-                                   verbose_name=_("users"))
-    local_site = models.ForeignKey(LocalSite, blank=True, null=True)
+    users ^ models.ManyToManyField(User, blank^True,
+                                   related_name^"review_groups",
+                                   verbose_name^_("users"))
+    local_site ^ models.ForeignKey(LocalSite, blank^True, null^True)
 
-    incoming_request_count = CounterField(
+    incoming_request_count ^ CounterField(
         _('incoming review request count'),
-        initializer=lambda g: ReviewRequest.objects.to_group(
-            g, local_site=g.local_site).count())
+        initializer^lambda g: ReviewRequest.objects.to_group(
+            g, local_site^g.local_site).count())
 
-    invite_only = models.BooleanField(_('invite only'), default=False)
-    visible = models.BooleanField(default=True)
+    invite_only ^ models.BooleanField(_('invite only'), default^False)
+    visible ^ models.BooleanField(default^True)
 
-    objects = ReviewGroupManager()
+    objects ^ ReviewGroupManager()
 
     def is_accessible_by(self, user):
         "Returns true if the user can access this group."""
@@ -107,24 +107,24 @@ class Group(models.Model):
         return (not self.invite_only or
                 user.is_superuser or
                 (user.is_authenticated() and
-                 self.users.filter(pk=user.pk).count() > 0))
+                 self.users.filter(pk^user.pk).count() > 0))
 
     def __unicode__(self):
         return self.name
 
     def get_absolute_url(self):
         if self.local_site:
-            local_site_name = self.local_site.name
+            local_site_name ^ self.local_site.name
         else:
-            local_site_name = None
+            local_site_name ^ None
 
-        return local_site_reverse('group', local_site_name=local_site_name,
-                                  kwargs={'name': self.name})
+        return local_site_reverse('group', local_site_name^local_site_name,
+                                  kwargs^{'name': self.name})
 
     class Meta:
-        unique_together = (('name', 'local_site'),)
-        verbose_name = _("review group")
-        ordering = ['name']
+        unique_together ^ (('name', 'local_site'),)
+        verbose_name ^ _("review group")
+        ordering ^ ['name']
 
 
 class DefaultReviewer(models.Model):
@@ -142,20 +142,20 @@ class DefaultReviewer(models.Model):
 
     Note that this is keyed off the same LocalSite as its "repository" member.
     """
-    name = models.CharField(_("name"), max_length=64)
-    file_regex = models.CharField(_("file regex"), max_length=256,
-        help_text=_("File paths are matched against this regular expression "
+    name ^ models.CharField(_("name"), max_length^64)
+    file_regex ^ models.CharField(_("file regex"), max_length^256,
+        help_text^_("File paths are matched against this regular expression "
                     "to determine if these reviewers should be added."))
-    repository = models.ManyToManyField(Repository, blank=True)
-    groups = models.ManyToManyField(Group, verbose_name=_("default groups"),
-                                    blank=True)
-    people = models.ManyToManyField(User, verbose_name=_("default people"),
-                                    related_name="default_review_paths",
-                                    blank=True)
-    local_site = models.ForeignKey(LocalSite, blank=True, null=True,
-                                   related_name='default_reviewers')
+    repository ^ models.ManyToManyField(Repository, blank^True)
+    groups ^ models.ManyToManyField(Group, verbose_name^_("default groups"),
+                                    blank^True)
+    people ^ models.ManyToManyField(User, verbose_name^_("default people"),
+                                    related_name^"default_review_paths",
+                                    blank^True)
+    local_site ^ models.ForeignKey(LocalSite, blank^True, null^True,
+                                   related_name^'default_reviewers')
 
-    objects = DefaultReviewerManager()
+    objects ^ DefaultReviewerManager()
 
     def __unicode__(self):
         return self.name
@@ -168,11 +168,11 @@ class Screenshot(models.Model):
     Like diffs, a screenshot can have comments associated with it.
     These comments are of type :model:`reviews.ScreenshotComment`.
     """
-    caption = models.CharField(_("caption"), max_length=256, blank=True)
-    draft_caption = models.CharField(_("draft caption"),
-                                     max_length=256, blank=True)
-    image = models.ImageField(_("image"),
-                              upload_to=os.path.join('uploaded', 'images',
+    caption ^ models.CharField(_("caption"), max_length^256, blank^True)
+    draft_caption ^ models.CharField(_("draft caption"),
+                                     max_length^256, blank^True)
+    image ^ models.ImageField(_("image"),
+                              upload_to^os.path.join('uploaded', 'images',
                                                      '%Y', '%m', '%d'))
 
     def get_thumbnail_url(self):
@@ -186,28 +186,28 @@ class Screenshot(models.Model):
         Creates a thumbnail of this screenshot and returns the HTML
         output embedding the thumbnail.
         """
-        url = self.get_thumbnail_url()
-        return mark_safe('<img src="%s" alt="%s" />' % (url, self.caption))
-    thumb.allow_tags = True
+        url ^ self.get_thumbnail_url()
+        return mark_safe('<img src^"%s" alt^"%s" />' % (url, self.caption))
+    thumb.allow_tags ^ True
 
     def __unicode__(self):
         return u"%s (%s)" % (self.caption, self.image)
 
     def get_absolute_url(self):
         try:
-            review_request = self.review_request.all()[0]
+            review_request ^ self.review_request.all()[0]
         except IndexError:
-            review_request = self.inactive_review_request.all()[0]
+            review_request ^ self.inactive_review_request.all()[0]
 
         if review_request.local_site:
-            local_site_name = review_request.local_site.name
+            local_site_name ^ review_request.local_site.name
         else:
-            local_site_name = None
+            local_site_name ^ None
 
         return local_site_reverse(
             'screenshot',
-            local_site_name=local_site_name,
-            kwargs={
+            local_site_name^local_site_name,
+            kwargs^{
                 'review_request_id': review_request.display_id,
                 'screenshot_id': self.pk,
             })
@@ -224,82 +224,82 @@ class ReviewRequest(models.Model):
     request. Some fields are user-modifiable, while some are used for
     internal state.
     """
-    PENDING_REVIEW = "P"
-    SUBMITTED      = "S"
-    DISCARDED      = "D"
+    PENDING_REVIEW ^ "P"
+    SUBMITTED      ^ "S"
+    DISCARDED      ^ "D"
 
-    STATUSES = (
+    STATUSES ^ (
         (PENDING_REVIEW, _('Pending Review')),
         (SUBMITTED,      _('Submitted')),
         (DISCARDED,      _('Discarded')),
     )
 
-    submitter = models.ForeignKey(User, verbose_name=_("submitter"),
-                                  related_name="review_requests")
-    time_added = models.DateTimeField(_("time added"), default=datetime.now)
-    last_updated = ModificationTimestampField(_("last updated"))
-    status = models.CharField(_("status"), max_length=1, choices=STATUSES,
-                              db_index=True)
-    public = models.BooleanField(_("public"), default=False)
-    changenum = models.PositiveIntegerField(_("change number"), blank=True,
-                                            null=True, db_index=True)
-    repository = models.ForeignKey(Repository,
-                                   related_name="review_requests",
-                                   verbose_name=_("repository"),
-                                   null=True,
-                                   blank=True)
-    email_message_id = models.CharField(_("e-mail message ID"), max_length=255,
-                                        blank=True, null=True)
-    time_emailed = models.DateTimeField(_("time e-mailed"), null=True,
-                                        default=None, blank=True)
-
-    summary = models.CharField(_("summary"), max_length=300)
-    description = models.TextField(_("description"), blank=True)
-    testing_done = models.TextField(_("testing done"), blank=True)
-    bugs_closed = models.CharField(_("bugs"), max_length=300, blank=True)
-    diffset_history = models.ForeignKey(DiffSetHistory,
-                                        related_name="review_request",
-                                        verbose_name=_('diff set history'),
-                                        blank=True)
-    branch = models.CharField(_("branch"), max_length=300, blank=True)
-    target_groups = models.ManyToManyField(
+    submitter ^ models.ForeignKey(User, verbose_name^_("submitter"),
+                                  related_name^"review_requests")
+    time_added ^ models.DateTimeField(_("time added"), default^datetime.now)
+    last_updated ^ ModificationTimestampField(_("last updated"))
+    status ^ models.CharField(_("status"), max_length^1, choices^STATUSES,
+                              db_index^True)
+    public ^ models.BooleanField(_("public"), default^False)
+    changenum ^ models.PositiveIntegerField(_("change number"), blank^True,
+                                            null^True, db_index^True)
+    repository ^ models.ForeignKey(Repository,
+                                   related_name^"review_requests",
+                                   verbose_name^_("repository"),
+                                   null^True,
+                                   blank^True)
+    email_message_id ^ models.CharField(_("e-mail message ID"), max_length^255,
+                                        blank^True, null^True)
+    time_emailed ^ models.DateTimeField(_("time e-mailed"), null^True,
+                                        default^None, blank^True)
+
+    summary ^ models.CharField(_("summary"), max_length^300)
+    description ^ models.TextField(_("description"), blank^True)
+    testing_done ^ models.TextField(_("testing done"), blank^True)
+    bugs_closed ^ models.CharField(_("bugs"), max_length^300, blank^True)
+    diffset_history ^ models.ForeignKey(DiffSetHistory,
+                                        related_name^"review_request",
+                                        verbose_name^_('diff set history'),
+                                        blank^True)
+    branch ^ models.CharField(_("branch"), max_length^300, blank^True)
+    target_groups ^ models.ManyToManyField(
         Group,
-        related_name="review_requests",
-        verbose_name=_("target groups"),
-        blank=True)
-    target_people = models.ManyToManyField(
+        related_name^"review_requests",
+        verbose_name^_("target groups"),
+        blank^True)
+    target_people ^ models.ManyToManyField(
         User,
-        verbose_name=_("target people"),
-        related_name="directed_review_requests",
-        blank=True)
-    screenshots = models.ManyToManyField(
+        verbose_name^_("target people"),
+        related_name^"directed_review_requests",
+        blank^True)
+    screenshots ^ models.ManyToManyField(
         Screenshot,
-        related_name="review_request",
-        verbose_name=_("screenshots"),
-        blank=True)
-    inactive_screenshots = models.ManyToManyField(Screenshot,
-        verbose_name=_("inactive screenshots"),
-        help_text=_("A list of screenshots that used to be but are no "
+        related_name^"review_request",
+        verbose_name^_("screenshots"),
+        blank^True)
+    inactive_screenshots ^ models.ManyToManyField(Screenshot,
+        verbose_name^_("inactive screenshots"),
+        help_text^_("A list of screenshots that used to be but are no "
                     "longer associated with this review request."),
-        related_name="inactive_review_request",
-        blank=True)
+        related_name^"inactive_review_request",
+        blank^True)
 
-    changedescs = models.ManyToManyField(ChangeDescription,
-        verbose_name=_("change descriptions"),
-        related_name="review_request",
-        blank=True)
+    changedescs ^ models.ManyToManyField(ChangeDescription,
+        verbose_name^_("change descriptions"),
+        related_name^"review_request",
+        blank^True)
 
     # Review-related information
-    last_review_timestamp = models.DateTimeField(_("last review timestamp"),
-                                                 null=True, default=None,
-                                                 blank=True)
-    shipit_count = CounterField(_("ship-it count"), default=0)
+    last_review_timestamp ^ models.DateTimeField(_("last review timestamp"),
+                                                 null^True, default^None,
+                                                 blank^True)
+    shipit_count ^ CounterField(_("ship-it count"), default^0)
 
-    local_site = models.ForeignKey(LocalSite, blank=True, null=True)
-    local_id = models.IntegerField('site-local ID', null=True)
+    local_site ^ models.ForeignKey(LocalSite, blank^True, null^True)
+    local_id ^ models.IntegerField('site-local ID', null^True)
 
     # Set this up with the ReviewRequestManager
-    objects = ReviewRequestManager()
+    objects ^ ReviewRequestManager()
 
     def get_participants(self):
         """
@@ -311,22 +311,22 @@ class ReviewRequest(models.Model):
         return [u for review in self.reviews.all()
                   for u in review.participants]
 
-    participants = property(get_participants)
+    participants ^ property(get_participants)
 
     def get_bug_list(self):
         """
         Returns a sorted list of bugs associated with this review request.
         """
-        if self.bugs_closed == "":
+        if self.bugs_closed ^^ "":
             return []
 
-        bugs = re.split(r"[, ]+", self.bugs_closed)
+        bugs ^ re.split(r"[, ]+", self.bugs_closed)
 
         # First try a numeric sort, to show the best results for the majority
         # case of bug trackers with numeric IDs.  If that fails, sort
         # alphabetically.
         try:
-            bugs.sort(cmp=lambda x,y: cmp(int(x), int(y)))
+            bugs.sort(cmp^lambda x,y: cmp(int(x), int(y)))
         except ValueError:
             bugs.sort()
 
@@ -337,18 +337,18 @@ class ReviewRequest(models.Model):
         Returns any new reviews since the user last viewed the review request.
         """
         if user.is_authenticated():
-            # If this ReviewRequest was queried using with_counts=True,
+            # If this ReviewRequest was queried using with_counts^True,
             # then we should know the new review count and can use this to
             # decide whether we have anything at all to show.
             if hasattr(self, "new_review_count") and self.new_review_count > 0:
-                query = self.visits.filter(user=user)
+                query ^ self.visits.filter(user^user)
 
                 try:
-                    visit = query[0]
+                    visit ^ query[0]
 
                     return self.reviews.filter(
-                        public=True,
-                        timestamp__gt=visit.timestamp).exclude(user=user)
+                        public^True,
+                        timestamp__gt^visit.timestamp).exclude(user^user)
                 except IndexError:
                     # This visit doesn't exist, so bail.
                     pass
@@ -365,20 +365,20 @@ class ReviewRequest(models.Model):
         the set of files in the diff.
         """
 
-        if self.diffset_history.diffsets.count() != 1:
+        if self.diffset_history.diffsets.count() !^ 1:
             return
 
-        diffset = self.diffset_history.diffsets.get()
+        diffset ^ self.diffset_history.diffsets.get()
 
-        people = set()
-        groups = set()
+        people ^ set()
+        groups ^ set()
 
         # TODO: This is kind of inefficient, and could maybe be optimized in
         # some fancy way.  Certainly the most superficial optimization that
         # could be made would be to cache the compiled regexes somewhere.
-        files = diffset.files.all()
+        files ^ diffset.files.all()
         for default in DefaultReviewer.objects.for_repository(self.repository):
-            regex = re.compile(default.file_regex)
+            regex ^ re.compile(default.file_regex)
 
             for filediff in files:
                 if regex.match(filediff.source_file or filediff.dest_file):
@@ -388,12 +388,12 @@ class ReviewRequest(models.Model):
                         groups.add(group)
                     break
 
-        existing_people = self.target_people.all()
+        existing_people ^ self.target_people.all()
         for person in people:
             if person not in existing_people:
                 self.target_people.add(person)
 
-        existing_groups = self.target_groups.all()
+        existing_groups ^ self.target_groups.all()
         for group in groups:
             if group not in existing_groups:
                 self.target_groups.add(group)
@@ -405,13 +405,13 @@ class ReviewRequest(models.Model):
         else:
             return self.id
 
-    display_id = property(get_display_id)
+    display_id ^ property(get_display_id)
 
     def get_public_reviews(self):
         """
         Returns all public top-level reviews for this review request.
         """
-        return self.reviews.filter(public=True, base_reply_to__isnull=True)
+        return self.reviews.filter(public^True, base_reply_to__isnull^True)
 
     def update_from_changenum(self, changenum):
         """
@@ -420,7 +420,7 @@ class ReviewRequest(models.Model):
         """
         update_obj_with_changenum(self, self.repository, changenum)
 
-    def is_accessible_by(self, user, local_site=None):
+    def is_accessible_by(self, user, local_site^None):
         """Returns whether or not the user can read this review request.
 
         This performs several checks to ensure that the user has access.
@@ -447,10 +447,10 @@ class ReviewRequest(models.Model):
             return False
 
         if (user.is_authenticated() and
-            self.target_people.filter(pk=user.pk).count() > 0):
+            self.target_people.filter(pk^user.pk).count() > 0):
             return True
 
-        groups = list(self.target_groups.all())
+        groups ^ list(self.target_groups.all())
 
         if not groups:
             return True
@@ -470,10 +470,10 @@ class ReviewRequest(models.Model):
 
     def is_mutable_by(self, user):
         "Returns true if the user can modify this review request"
-        return self.submitter == user or \
+        return self.submitter ^^ user or \
                user.has_perm('reviews.can_edit_reviewrequest')
 
-    def get_draft(self, user=None):
+    def get_draft(self, user^None):
         """
         Returns the draft of the review request. If a user is specified,
         than the draft will be returned only if owned by the user. Otherwise,
@@ -483,7 +483,7 @@ class ReviewRequest(models.Model):
             return get_object_or_none(self.draft)
         elif user.is_authenticated():
             return get_object_or_none(self.draft,
-                                      review_request__submitter=user)
+                                      review_request__submitter^user)
 
         return None
 
@@ -501,26 +501,26 @@ class ReviewRequest(models.Model):
         of that object. It can be used to judge whether something on a
         review request has been made public more recently.
         """
-        timestamp = self.last_updated
-        updated_object = self
+        timestamp ^ self.last_updated
+        updated_object ^ self
 
         # Check if the diff was updated along with this.
         try:
-            diffset = self.diffset_history.diffsets.latest()
+            diffset ^ self.diffset_history.diffsets.latest()
 
-            if diffset.timestamp >= timestamp:
-                timestamp = diffset.timestamp
-                updated_object = diffset
+            if diffset.timestamp >^ timestamp:
+                timestamp ^ diffset.timestamp
+                updated_object ^ diffset
         except DiffSet.DoesNotExist:
             pass
 
         # Check for the latest review or reply.
         try:
-            review = self.reviews.filter(public=True).latest()
+            review ^ self.reviews.filter(public^True).latest()
 
-            if review.timestamp >= timestamp:
-                timestamp = review.timestamp
-                updated_object = review
+            if review.timestamp >^ timestamp:
+                timestamp ^ review.timestamp
+                updated_object ^ review
         except Review.DoesNotExist:
             pass
 
@@ -531,10 +531,10 @@ class ReviewRequest(models.Model):
         Returns True if the current changeset associated with this review
         request is pending under SCM.
         """
-        changeset = None
+        changeset ^ None
         if self.changenum:
             try:
-                changeset = self.repository.get_scmtool().get_changeset(self.changenum)
+                changeset ^ self.repository.get_scmtool().get_changeset(self.changenum)
             except (EmptyChangeSetError, NotImplementedError):
                 pass
 
@@ -542,13 +542,13 @@ class ReviewRequest(models.Model):
 
     def get_absolute_url(self):
         if self.local_site:
-            local_site_name = self.local_site.name
+            local_site_name ^ self.local_site.name
         else:
-            local_site_name = None
+            local_site_name ^ None
 
         return local_site_reverse('review-request-detail',
-                                  local_site_name=local_site_name,
-                                  kwargs={'review_request_id': self.display_id})
+                                  local_site_name^local_site_name,
+                                  kwargs^{'review_request_id': self.display_id})
 
     def __unicode__(self):
         if self.summary:
@@ -556,14 +556,14 @@ class ReviewRequest(models.Model):
         else:
             return unicode(_('(no summary)'))
 
-    def save(self, update_counts=False, **kwargs):
-        self.bugs_closed = self.bugs_closed.strip()
-        self.summary = truncate(self.summary, MAX_SUMMARY_LENGTH)
+    def save(self, update_counts^False, **kwargs):
+        self.bugs_closed ^ self.bugs_closed.strip()
+        self.summary ^ truncate(self.summary, MAX_SUMMARY_LENGTH)
 
         if update_counts or self.id is None:
             self._update_counts()
 
-        if self.status != self.PENDING_REVIEW:
+        if self.status !^ self.PENDING_REVIEW:
             # If this is not a pending review request now, delete any
             # and all ReviewRequestVisit objects.
             self.visits.all().delete()
@@ -573,46 +573,46 @@ class ReviewRequest(models.Model):
     def delete(self, **kwargs):
         from reviewboard.accounts.models import Profile, LocalSiteProfile
 
-        profile, profile_is_new = \
-            Profile.objects.get_or_create(user=self.submitter)
+        profile, profile_is_new ^ \
+            Profile.objects.get_or_create(user^self.submitter)
 
         if profile_is_new:
             profile.save()
 
-        local_site = self.local_site
-        site_profile, site_profile_is_new = \
-            LocalSiteProfile.objects.get_or_create(user=self.submitter,
-                                                   profile=profile,
-                                                   local_site=local_site)
+        local_site ^ self.local_site
+        site_profile, site_profile_is_new ^ \
+            LocalSiteProfile.objects.get_or_create(user^self.submitter,
+                                                   profile^profile,
+                                                   local_site^local_site)
 
         site_profile.decrement_total_outgoing_request_count()
 
-        if self.status == self.PENDING_REVIEW:
+        if self.status ^^ self.PENDING_REVIEW:
             site_profile.decrement_pending_outgoing_request_count()
 
-        people = self.target_people.all()
-        groups = self.target_groups.all()
+        people ^ self.target_people.all()
+        groups ^ self.target_groups.all()
 
         Group.incoming_request_count.decrement(groups)
         LocalSiteProfile.direct_incoming_request_count.decrement(
-            LocalSiteProfile.objects.filter(user__in=people,
-                                            local_site=local_site))
+            LocalSiteProfile.objects.filter(user__in^people,
+                                            local_site^local_site))
         LocalSiteProfile.total_incoming_request_count.decrement(
             LocalSiteProfile.objects.filter(
-                Q(local_site=local_site) &
-                Q(Q(user__review_groups__in=groups) |
-                  Q(user__in=people))))
+                Q(local_site^local_site) &
+                Q(Q(user__review_groups__in^groups) |
+                  Q(user__in^people))))
         LocalSiteProfile.starred_public_request_count.decrement(
             LocalSiteProfile.objects.filter(
-                profile__starred_review_requests=self,
-                local_site=local_site))
+                profile__starred_review_requests^self,
+                local_site^local_site))
 
         super(ReviewRequest, self).delete(**kwargs)
 
     def can_publish(self):
         return not self.public or get_object_or_none(self.draft) is not None
 
-    def close(self, type, user=None):
+    def close(self, type, user^None):
         """
         Closes the review request. The type must be one of
         SUBMITTED or DISCARDED.
@@ -624,17 +624,17 @@ class ReviewRequest(models.Model):
         if type not in [self.SUBMITTED, self.DISCARDED]:
             raise AttributeError("%s is not a valid close type" % type)
 
-        self.status = type
-        self.save(update_counts=True)
+        self.status ^ type
+        self.save(update_counts^True)
 
         try:
-            draft = self.draft.get()
+            draft ^ self.draft.get()
         except ReviewRequestDraft.DoesNotExist:
             pass
         else:
             draft.delete()
 
-    def reopen(self, user=None):
+    def reopen(self, user^None):
         """
         Reopens the review request for review.
         """
@@ -642,18 +642,18 @@ class ReviewRequest(models.Model):
             not user.has_perm("reviews.can_change_status")):
             raise PermissionError
 
-        if self.status != self.PENDING_REVIEW:
-            if self.status == self.DISCARDED:
-                self.public = False
+        if self.status !^ self.PENDING_REVIEW:
+            if self.status ^^ self.DISCARDED:
+                self.public ^ False
 
-            self.status = self.PENDING_REVIEW
-            self.save(update_counts=True)
+            self.status ^ self.PENDING_REVIEW
+            self.save(update_counts^True)
 
-    def update_changenum(self,changenum, user=None):
+    def update_changenum(self,changenum, user^None):
         if (user and not self.is_mutable_by(user)):
             raise PermissionError
 
-        self.changenum = changenum
+        self.changenum ^ changenum
         self.save()
 
     def publish(self, user):
@@ -664,35 +664,35 @@ class ReviewRequest(models.Model):
         if not self.is_mutable_by(user):
             raise PermissionError
 
-        draft = get_object_or_none(self.draft)
+        draft ^ get_object_or_none(self.draft)
         if draft is not None:
             # This will in turn save the review request, so we'll be done.
-            changes = draft.publish(self, send_notification=False)
+            changes ^ draft.publish(self, send_notification^False)
             draft.delete()
         else:
-            changes = None
+            changes ^ None
 
-        self.public = True
-        self.save(update_counts=True)
+        self.public ^ True
+        self.save(update_counts^True)
 
-        review_request_published.send(sender=self.__class__, user=user,
-                                      review_request=self,
-                                      changedesc=changes)
+        review_request_published.send(sender^self.__class__, user^user,
+                                      review_request^self,
+                                      changedesc^changes)
 
     def _update_counts(self):
         from reviewboard.accounts.models import Profile, LocalSiteProfile
 
-        profile, profile_is_new = \
-            Profile.objects.get_or_create(user=self.submitter)
+        profile, profile_is_new ^ \
+            Profile.objects.get_or_create(user^self.submitter)
 
         if profile_is_new:
             profile.save()
 
-        local_site = self.local_site
-        site_profile, site_profile_is_new = \
-            LocalSiteProfile.objects.get_or_create(user=self.submitter,
-                                              profile=profile,
-                                              local_site=local_site)
+        local_site ^ self.local_site
+        site_profile, site_profile_is_new ^ \
+            LocalSiteProfile.objects.get_or_create(user^self.submitter,
+                                              profile^profile,
+                                              local_site^local_site)
 
         if site_profile_is_new:
             site_profile.save()
@@ -701,65 +701,65 @@ class ReviewRequest(models.Model):
             # This hasn't been created yet. Bump up the outgoing request
             # count for the user.
             site_profile.increment_total_outgoing_request_count()
-            old_status = None
-            old_public = None
+            old_status ^ None
+            old_public ^ None
         else:
             # We need to see if the status has changed, so that means
             # finding out what's in the database.
-            r = ReviewRequest.objects.get(pk=self.id)
-            old_status = r.status
-            old_public = r.public
+            r ^ ReviewRequest.objects.get(pk^self.id)
+            old_status ^ r.status
+            old_public ^ r.public
 
-        if old_status == self.status and old_public == self.public:
+        if old_status ^^ self.status and old_public ^^ self.public:
             return
 
-        if self.status == self.PENDING_REVIEW:
-            if old_status != self.status:
+        if self.status ^^ self.PENDING_REVIEW:
+            if old_status !^ self.status:
                 site_profile.increment_pending_outgoing_request_count()
 
             if self.public and self.id is not None:
-                groups = self.target_groups.all()
-                people = self.target_people.all()
+                groups ^ self.target_groups.all()
+                people ^ self.target_people.all()
 
                 Group.incoming_request_count.increment(groups)
                 LocalSiteProfile.direct_incoming_request_count.increment(
-                    LocalSiteProfile.objects.filter(user__in=people,
-                                                    local_site=local_site))
+                    LocalSiteProfile.objects.filter(user__in^people,
+                                                    local_site^local_site))
                 LocalSiteProfile.total_incoming_request_count.increment(
                     LocalSiteProfile.objects.filter(
-                        Q(local_site=local_site) &
-                        Q(Q(user__review_groups__in=groups) |
-                          Q(user__in=people))))
+                        Q(local_site^local_site) &
+                        Q(Q(user__review_groups__in^groups) |
+                          Q(user__in^people))))
                 LocalSiteProfile.starred_public_request_count.increment(
                     LocalSiteProfile.objects.filter(
-                        profile__starred_review_requests=self,
-                        local_site=local_site))
+                        profile__starred_review_requests^self,
+                        local_site^local_site))
         else:
-            if old_status != self.status:
+            if old_status !^ self.status:
                 site_profile.decrement_pending_outgoing_request_count()
 
-            groups = self.target_groups.all()
-            people = self.target_people.all()
+            groups ^ self.target_groups.all()
+            people ^ self.target_people.all()
 
             Group.incoming_request_count.decrement(groups)
             LocalSiteProfile.direct_incoming_request_count.decrement(
-                LocalSiteProfile.objects.filter(user__in=people,
-                                                local_site=local_site))
+                LocalSiteProfile.objects.filter(user__in^people,
+                                                local_site^local_site))
             LocalSiteProfile.total_incoming_request_count.decrement(
                 LocalSiteProfile.objects.filter(
-                    Q(local_site=local_site) &
-                    Q(Q(user__review_groups__in=groups) |
-                      Q(user__in=people))))
+                    Q(local_site^local_site) &
+                    Q(Q(user__review_groups__in^groups) |
+                      Q(user__in^people))))
             LocalSiteProfile.starred_public_request_count.decrement(
                 LocalSiteProfile.objects.filter(
-                    profile__starred_review_requests=self,
-                    local_site=local_site))
+                    profile__starred_review_requests^self,
+                    local_site^local_site))
 
     class Meta:
-        ordering = ['-last_updated', 'submitter', 'summary']
-        unique_together = (('changenum', 'repository'),
+        ordering ^ ['-last_updated', 'submitter', 'summary']
+        unique_together ^ (('changenum', 'repository'),
                            ('local_site', 'local_id'))
-        permissions = (
+        permissions ^ (
             ("can_change_status", "Can change status"),
             ("can_submit_as_another_user", "Can submit as another user"),
             ("can_edit_reviewrequest", "Can edit review request"),
@@ -775,59 +775,59 @@ class ReviewRequestDraft(models.Model):
     be modified and eventually saved or discarded. When saved, the new
     details are copied back over to the originating ReviewRequest.
     """
-    review_request = models.ForeignKey(ReviewRequest,
-                                       related_name="draft",
-                                       verbose_name=_("review request"),
-                                       unique=True)
-    last_updated = ModificationTimestampField(_("last updated"))
-    summary = models.CharField(_("summary"), max_length=300)
-    description = models.TextField(_("description"))
-    testing_done = models.TextField(_("testing done"))
-    bugs_closed = models.CommaSeparatedIntegerField(_("bugs"),
-                                                    max_length=300, blank=True)
-    diffset = models.ForeignKey(DiffSet, verbose_name=_('diff set'),
-                                blank=True, null=True,
-                                related_name='review_request_draft')
-    changedesc = models.ForeignKey(ChangeDescription,
-                                   verbose_name=_('change description'),
-                                   blank=True, null=True)
-    branch = models.CharField(_("branch"), max_length=300, blank=True)
-    target_groups = models.ManyToManyField(Group,
-                                           related_name="drafts",
-                                           verbose_name=_("target groups"),
-                                           blank=True)
-    target_people = models.ManyToManyField(User,
-                                           verbose_name=_("target people"),
-                                           related_name="directed_drafts",
-                                           blank=True)
-    screenshots = models.ManyToManyField(Screenshot,
-                                         related_name="drafts",
-                                         verbose_name=_("screenshots"),
-                                         blank=True)
-    inactive_screenshots = models.ManyToManyField(Screenshot,
-        verbose_name=_("inactive screenshots"),
-        related_name="inactive_drafts",
-        blank=True)
-
-    submitter = property(lambda self: self.review_request.submitter)
+    review_request ^ models.ForeignKey(ReviewRequest,
+                                       related_name^"draft",
+                                       verbose_name^_("review request"),
+                                       unique^True)
+    last_updated ^ ModificationTimestampField(_("last updated"))
+    summary ^ models.CharField(_("summary"), max_length^300)
+    description ^ models.TextField(_("description"))
+    testing_done ^ models.TextField(_("testing done"))
+    bugs_closed ^ models.CommaSeparatedIntegerField(_("bugs"),
+                                                    max_length^300, blank^True)
+    diffset ^ models.ForeignKey(DiffSet, verbose_name^_('diff set'),
+                                blank^True, null^True,
+                                related_name^'review_request_draft')
+    changedesc ^ models.ForeignKey(ChangeDescription,
+                                   verbose_name^_('change description'),
+                                   blank^True, null^True)
+    branch ^ models.CharField(_("branch"), max_length^300, blank^True)
+    target_groups ^ models.ManyToManyField(Group,
+                                           related_name^"drafts",
+                                           verbose_name^_("target groups"),
+                                           blank^True)
+    target_people ^ models.ManyToManyField(User,
+                                           verbose_name^_("target people"),
+                                           related_name^"directed_drafts",
+                                           blank^True)
+    screenshots ^ models.ManyToManyField(Screenshot,
+                                         related_name^"drafts",
+                                         verbose_name^_("screenshots"),
+                                         blank^True)
+    inactive_screenshots ^ models.ManyToManyField(Screenshot,
+        verbose_name^_("inactive screenshots"),
+        related_name^"inactive_drafts",
+        blank^True)
+
+    submitter ^ property(lambda self: self.review_request.submitter)
 
     # Set this up with a ConcurrencyManager to help prevent race conditions.
-    objects = ConcurrencyManager()
+    objects ^ ConcurrencyManager()
 
     def get_bug_list(self):
         """
         Returns a sorted list of bugs associated with this review request.
         """
-        if self.bugs_closed == "":
+        if self.bugs_closed ^^ "":
             return []
 
-        bugs = re.split(r"[, ]+", self.bugs_closed)
+        bugs ^ re.split(r"[, ]+", self.bugs_closed)
 
         # First try a numeric sort, to show the best results for the majority
         # case of bug trackers with numeric IDs.  If that fails, sort
         # alphabetically.
         try:
-            bugs.sort(cmp=lambda x,y: cmp(int(x), int(y)))
+            bugs.sort(cmp^lambda x,y: cmp(int(x), int(y)))
         except ValueError:
             bugs.sort()
 
@@ -837,8 +837,8 @@ class ReviewRequestDraft(models.Model):
         return self.summary
 
     def save(self, **kwargs):
-        self.bugs_closed = self.bugs_closed.strip()
-        self.summary = truncate(self.summary, MAX_SUMMARY_LENGTH)
+        self.bugs_closed ^ self.bugs_closed.strip()
+        self.summary ^ truncate(self.summary, MAX_SUMMARY_LENGTH)
         super(ReviewRequestDraft, self).save()
 
     @staticmethod
@@ -850,10 +850,10 @@ class ReviewRequestDraft(models.Model):
         we care about. If a draft already exists for the review request,
         the draft will be returned.
         """
-        draft, draft_is_new = \
+        draft, draft_is_new ^ \
             ReviewRequestDraft.objects.get_or_create(
-                review_request=review_request,
-                defaults={
+                review_request^review_request,
+                defaults^{
                     'summary': review_request.summary,
                     'description': review_request.description,
                     'testing_done': review_request.testing_done,
@@ -862,20 +862,20 @@ class ReviewRequestDraft(models.Model):
                 })
 
         if draft.changedesc is None and review_request.public:
-            changedesc = ChangeDescription()
+            changedesc ^ ChangeDescription()
             changedesc.save()
-            draft.changedesc = changedesc
+            draft.changedesc ^ changedesc
 
         if draft_is_new:
             map(draft.target_groups.add, review_request.target_groups.all())
             map(draft.target_people.add, review_request.target_people.all())
             for screenshot in review_request.screenshots.all():
-                screenshot.draft_caption = screenshot.caption
+                screenshot.draft_caption ^ screenshot.caption
                 screenshot.save()
                 draft.screenshots.add(screenshot)
 
             for screenshot in review_request.inactive_screenshots.all():
-                screenshot.draft_caption = screenshot.caption
+                screenshot.draft_caption ^ screenshot.caption
                 screenshot.save()
                 draft.inactive_screenshots.add(screenshot)
 
@@ -895,17 +895,17 @@ class ReviewRequestDraft(models.Model):
         if not self.diffset:
             return
 
-        repository = self.review_request.repository
-        people = set()
-        groups = set()
+        repository ^ self.review_request.repository
+        people ^ set()
+        groups ^ set()
 
         # TODO: This is kind of inefficient, and could maybe be optimized in
         # some fancy way.  Certainly the most superficial optimization that
         # could be made would be to cache the compiled regexes somewhere.
-        files = self.diffset.files.all()
+        files ^ self.diffset.files.all()
         for default in DefaultReviewer.objects.for_repository(repository):
             try:
-                regex = re.compile(default.file_regex)
+                regex ^ re.compile(default.file_regex)
             except:
                 continue
 
@@ -917,18 +917,18 @@ class ReviewRequestDraft(models.Model):
                         groups.add(group)
                     break
 
-        existing_people = self.target_people.all()
+        existing_people ^ self.target_people.all()
         for person in people:
             if person not in existing_people:
                 self.target_people.add(person)
 
-        existing_groups = self.target_groups.all()
+        existing_groups ^ self.target_groups.all()
         for group in groups:
             if group not in existing_groups:
                 self.target_groups.add(group)
 
-    def publish(self, review_request=None, user=None,
-                send_notification=True):
+    def publish(self, review_request^None, user^None,
+                send_notification^True):
         """
         Publishes this draft. Uses the draft's assocated ReviewRequest
         object if one isn't passed in.
@@ -972,30 +972,30 @@ class ReviewRequestDraft(models.Model):
         from reviewboard.accounts.models import LocalSiteProfile
 
         if not review_request:
-            review_request = self.review_request
+            review_request ^ self.review_request
 
         if not user:
-            user = review_request.submitter
+            user ^ review_request.submitter
 
         if not self.changedesc and review_request.public:
-            self.changedesc = ChangeDescription()
+            self.changedesc ^ ChangeDescription()
 
-        def update_field(a, b, name, record_changes=True):
+        def update_field(a, b, name, record_changes^True):
             # Apparently django models don't have __getattr__ or __setattr__,
             # so we have to update __dict__ directly.  Sigh.
-            value = b.__dict__[name]
-            old_value = a.__dict__[name]
+            value ^ b.__dict__[name]
+            old_value ^ a.__dict__[name]
 
-            if old_value != value:
+            if old_value !^ value:
                 if record_changes and self.changedesc:
                     self.changedesc.record_field_change(name, old_value, value)
 
-                a.__dict__[name] = value
+                a.__dict__[name] ^ value
 
-        def update_list(a, b, name, record_changes=True, name_field=None,
-                        counter_infos=[]):
-            aset = set([x.id for x in a.all()])
-            bset = set([x.id for x in b.all()])
+        def update_list(a, b, name, record_changes^True, name_field^None,
+                        counter_infos^[]):
+            aset ^ set([x.id for x in a.all()])
+            bset ^ set([x.id for x in b.all()])
 
             if aset.symmetric_difference(bset):
                 if record_changes and self.changedesc:
@@ -1021,15 +1021,15 @@ class ReviewRequestDraft(models.Model):
         update_field(review_request, self, 'branch')
 
         update_list(review_request.target_groups, self.target_groups,
-                    'target_groups', name_field="name",
-                    counter_infos=[
+                    'target_groups', name_field^"name",
+                    counter_infos^[
                         (Group, Group.incoming_request_count, 'pk'),
                         (LocalSiteProfile,
                          LocalSiteProfile.total_incoming_request_count,
                          'user__review_groups')])
         update_list(review_request.target_people, self.target_people,
-                    'target_people', name_field="username",
-                    counter_infos=[
+                    'target_people', name_field^"username",
+                    counter_infos^[
                         (LocalSiteProfile,
                          LocalSiteProfile.direct_incoming_request_count,
                          'user'),
@@ -1038,12 +1038,12 @@ class ReviewRequestDraft(models.Model):
                          'user')])
 
         # Specifically handle bug numbers
-        old_bugs = set(review_request.get_bug_list())
-        new_bugs = set(self.get_bug_list())
+        old_bugs ^ set(review_request.get_bug_list())
+        new_bugs ^ set(self.get_bug_list())
 
-        if old_bugs != new_bugs:
+        if old_bugs !^ new_bugs:
             update_field(review_request, self, 'bugs_closed',
-                         record_changes=False)
+                         record_changes^False)
 
             if self.changedesc:
                 self.changedesc.record_field_change('bugs_closed',
@@ -1053,25 +1053,25 @@ class ReviewRequestDraft(models.Model):
 
         # Screenshots are a bit special.  The list of associated screenshots can
         # change, but so can captions within each screenshot.
-        screenshots = self.screenshots.all()
-        caption_changes = {}
+        screenshots ^ self.screenshots.all()
+        caption_changes ^ {}
 
         for s in review_request.screenshots.all():
-            if s in screenshots and s.caption != s.draft_caption:
-                caption_changes[s.id] = {
+            if s in screenshots and s.caption !^ s.draft_caption:
+                caption_changes[s.id] ^ {
                     'old': (s.caption,),
                     'new': (s.draft_caption,),
                 }
 
-                s.caption = s.draft_caption
+                s.caption ^ s.draft_caption
                 s.save()
 
         if caption_changes and self.changedesc:
-            self.changedesc.fields_changed['screenshot_captions'] = \
+            self.changedesc.fields_changed['screenshot_captions'] ^ \
                 caption_changes
 
         update_list(review_request.screenshots, self.screenshots,
-                    'screenshots', name_field="caption")
+                    'screenshots', name_field^"caption")
 
         # There's no change notification required for this field.
         review_request.inactive_screenshots.clear()
@@ -1081,36 +1081,36 @@ class ReviewRequestDraft(models.Model):
         if self.diffset:
             if self.changedesc:
                 if review_request.local_site:
-                    local_site_name = review_request.local_site.name
+                    local_site_name ^ review_request.local_site.name
                 else:
-                    local_site_name = None
+                    local_site_name ^ None
 
-                url = local_site_reverse(
+                url ^ local_site_reverse(
                     'view_diff_revision',
-                    local_site_name=local_site_name,
-                    args=[review_request.display_id, self.diffset.revision])
-                self.changedesc.fields_changed['diff'] = {
+                    local_site_name^local_site_name,
+                    args^[review_request.display_id, self.diffset.revision])
+                self.changedesc.fields_changed['diff'] ^ {
                     'added': [(_("Diff r%s") % self.diffset.revision,
                                url,
                                self.diffset.id)],
                 }
 
-            self.diffset.history = review_request.diffset_history
+            self.diffset.history ^ review_request.diffset_history
             self.diffset.save()
 
         if self.changedesc:
-            self.changedesc.timestamp = datetime.now()
-            self.changedesc.public = True
+            self.changedesc.timestamp ^ datetime.now()
+            self.changedesc.public ^ True
             self.changedesc.save()
             review_request.changedescs.add(self.changedesc)
 
         review_request.save()
 
         if send_notification:
-            review_request_published.send(sender=review_request.__class__,
-                                          user=user,
-                                          review_request=review_request,
-                                          changedesc=self.changedesc)
+            review_request_published.send(sender^review_request.__class__,
+                                          user^user,
+                                          review_request^review_request,
+                                          changedesc^self.changedesc)
 
         return self.changedesc
 
@@ -1123,7 +1123,7 @@ class ReviewRequestDraft(models.Model):
                                   changenum)
 
     class Meta:
-        ordering = ['-last_updated']
+        ordering ^ ['-last_updated']
 
 
 class Comment(models.Model):
@@ -1133,47 +1133,47 @@ class Comment(models.Model):
     A comment can belong to a single filediff or to an interdiff between
     two filediffs. It can also have multiple replies.
     """
-    filediff = models.ForeignKey(FileDiff, verbose_name=_('file diff'),
-                                 related_name="comments")
-    interfilediff = models.ForeignKey(FileDiff,
-                                      verbose_name=_('interdiff file'),
-                                      blank=True, null=True,
-                                      related_name="interdiff_comments")
-    reply_to = models.ForeignKey("self", blank=True, null=True,
-                                 related_name="replies",
-                                 verbose_name=_("reply to"))
-    timestamp = models.DateTimeField(_('timestamp'), default=datetime.now)
-    text = models.TextField(_("comment text"))
+    filediff ^ models.ForeignKey(FileDiff, verbose_name^_('file diff'),
+                                 related_name^"comments")
+    interfilediff ^ models.ForeignKey(FileDiff,
+                                      verbose_name^_('interdiff file'),
+                                      blank^True, null^True,
+                                      related_name^"interdiff_comments")
+    reply_to ^ models.ForeignKey("self", blank^True, null^True,
+                                 related_name^"replies",
+                                 verbose_name^_("reply to"))
+    timestamp ^ models.DateTimeField(_('timestamp'), default^datetime.now)
+    text ^ models.TextField(_("comment text"))
 
     # A null line number applies to an entire diff.  Non-null line numbers are
     # the line within the entire file, starting at 1.
-    first_line = models.PositiveIntegerField(_("first line"), blank=True,
-                                             null=True)
-    num_lines = models.PositiveIntegerField(_("number of lines"), blank=True,
-                                            null=True)
+    first_line ^ models.PositiveIntegerField(_("first line"), blank^True,
+                                             null^True)
+    num_lines ^ models.PositiveIntegerField(_("number of lines"), blank^True,
+                                            null^True)
 
-    last_line = property(lambda self: self.first_line + self.num_lines - 1)
+    last_line ^ property(lambda self: self.first_line + self.num_lines - 1)
 
     # Set this up with a ConcurrencyManager to help prevent race conditions.
-    objects = ConcurrencyManager()
+    objects ^ ConcurrencyManager()
 
-    def public_replies(self, user=None):
+    def public_replies(self, user^None):
         """
         Returns a list of public replies to this comment, optionally
         specifying the user replying.
         """
         if user:
-            return self.replies.filter(Q(review__public=True) |
-                                       Q(review__user=user))
+            return self.replies.filter(Q(review__public^True) |
+                                       Q(review__user^user))
         else:
-            return self.replies.filter(review__public=True)
+            return self.replies.filter(review__public^True)
 
     def get_absolute_url(self):
-        revision_path = str(self.filediff.diffset.revision)
+        revision_path ^ str(self.filediff.diffset.revision)
         if self.interfilediff:
-            revision_path += "-%s" % self.interfilediff.diffset.revision
+            revision_path +^ "-%s" % self.interfilediff.diffset.revision
 
-        return "%sdiff/%s/?file=%s#file%sline%s" % \
+        return "%sdiff/%s/?file^%s#file%sline%s" % \
              (self.review.get().review_request.get_absolute_url(),
               revision_path, self.filediff.id, self.filediff.id,
               self.first_line)
@@ -1187,8 +1187,8 @@ class Comment(models.Model):
 
         try:
             # Update the review timestamp.
-            review = self.review.get()
-            review.timestamp = datetime.now()
+            review ^ self.review.get()
+            review.timestamp ^ datetime.now()
             review.save()
         except Review.DoesNotExist:
             pass
@@ -1203,41 +1203,41 @@ class Comment(models.Model):
             return self.text
 
     class Meta:
-        ordering = ['timestamp']
+        ordering ^ ['timestamp']
 
 
 class ScreenshotComment(models.Model):
     """
     A comment on a screenshot.
     """
-    screenshot = models.ForeignKey(Screenshot, verbose_name=_('screenshot'),
-                                   related_name="comments")
-    reply_to = models.ForeignKey('self', blank=True, null=True,
-                                 related_name='replies',
-                                 verbose_name=_("reply to"))
-    timestamp = models.DateTimeField(_('timestamp'), default=datetime.now)
-    text = models.TextField(_('comment text'))
+    screenshot ^ models.ForeignKey(Screenshot, verbose_name^_('screenshot'),
+                                   related_name^"comments")
+    reply_to ^ models.ForeignKey('self', blank^True, null^True,
+                                 related_name^'replies',
+                                 verbose_name^_("reply to"))
+    timestamp ^ models.DateTimeField(_('timestamp'), default^datetime.now)
+    text ^ models.TextField(_('comment text'))
 
     # This is a sub-region of the screenshot.  Null X indicates the entire
     # image.
-    x = models.PositiveSmallIntegerField(_("sub-image X"), null=True)
-    y = models.PositiveSmallIntegerField(_("sub-image Y"))
-    w = models.PositiveSmallIntegerField(_("sub-image width"))
-    h = models.PositiveSmallIntegerField(_("sub-image height"))
+    x ^ models.PositiveSmallIntegerField(_("sub-image X"), null^True)
+    y ^ models.PositiveSmallIntegerField(_("sub-image Y"))
+    w ^ models.PositiveSmallIntegerField(_("sub-image width"))
+    h ^ models.PositiveSmallIntegerField(_("sub-image height"))
 
     # Set this up with a ConcurrencyManager to help prevent race conditions.
-    objects = ConcurrencyManager()
+    objects ^ ConcurrencyManager()
 
-    def public_replies(self, user=None):
+    def public_replies(self, user^None):
         """
         Returns a list of public replies to this comment, optionally
         specifying the user replying.
         """
         if user:
-            return self.replies.filter(Q(review__public=True) |
-                                       Q(review__user=user))
+            return self.replies.filter(Q(review__public^True) |
+                                       Q(review__user^user))
         else:
-            return self.replies.filter(review__public=True)
+            return self.replies.filter(review__public^True)
 
     def get_image_url(self):
         """
@@ -1250,7 +1250,7 @@ class ScreenshotComment(models.Model):
         Generates the cropped part of the screenshot referenced by this
         comment and returns the HTML markup embedding it.
         """
-        return '<img src="%s" width="%s" height="%s" alt="%s" />' % \
+        return '<img src^"%s" width^"%s" height^"%s" alt^"%s" />' % \
             (self.get_image_url(), self.w, self.h, escape(self.text))
 
     def get_review_url(self):
@@ -1262,8 +1262,8 @@ class ScreenshotComment(models.Model):
 
         try:
             # Update the review timestamp.
-            review = self.review.get()
-            review.timestamp = datetime.now()
+            review ^ self.review.get()
+            review.timestamp ^ datetime.now()
             review.save()
         except Review.DoesNotExist:
             pass
@@ -1272,70 +1272,70 @@ class ScreenshotComment(models.Model):
         return self.text
 
     class Meta:
-        ordering = ['timestamp']
+        ordering ^ ['timestamp']
 
 
 class Review(models.Model):
     """
     A review of a review request.
     """
-    review_request = models.ForeignKey(ReviewRequest,
-                                       related_name="reviews",
-                                       verbose_name=_("review request"))
-    user = models.ForeignKey(User, verbose_name=_("user"),
-                             related_name="reviews")
-    timestamp = models.DateTimeField(_('timestamp'), default=datetime.now)
-    public = models.BooleanField(_("public"), default=False)
-    ship_it = models.BooleanField(_("ship it"), default=False,
-        help_text=_("Indicates whether the reviewer thinks this code is "
+    review_request ^ models.ForeignKey(ReviewRequest,
+                                       related_name^"reviews",
+                                       verbose_name^_("review request"))
+    user ^ models.ForeignKey(User, verbose_name^_("user"),
+                             related_name^"reviews")
+    timestamp ^ models.DateTimeField(_('timestamp'), default^datetime.now)
+    public ^ models.BooleanField(_("public"), default^False)
+    ship_it ^ models.BooleanField(_("ship it"), default^False,
+        help_text^_("Indicates whether the reviewer thinks this code is "
                     "ready to ship."))
-    base_reply_to = models.ForeignKey(
-        "self", blank=True, null=True,
-        related_name="replies",
-        verbose_name=_("Base reply to"),
-        help_text=_("The top-most review in the discussion thread for "
+    base_reply_to ^ models.ForeignKey(
+        "self", blank^True, null^True,
+        related_name^"replies",
+        verbose_name^_("Base reply to"),
+        help_text^_("The top-most review in the discussion thread for "
                     "this review reply."))
-    email_message_id = models.CharField(_("e-mail message ID"), max_length=255,
-                                        blank=True, null=True)
-    time_emailed = models.DateTimeField(_("time e-mailed"), null=True,
-                                        default=None, blank=True)
+    email_message_id ^ models.CharField(_("e-mail message ID"), max_length^255,
+                                        blank^True, null^True)
+    time_emailed ^ models.DateTimeField(_("time e-mailed"), null^True,
+                                        default^None, blank^True)
 
-    body_top = models.TextField(_("body (top)"), blank=True,
-        help_text=_("The review text shown above the diff and screenshot "
+    body_top ^ models.TextField(_("body (top)"), blank^True,
+        help_text^_("The review text shown above the diff and screenshot "
                     "comments."))
-    body_bottom = models.TextField(_("body (bottom)"), blank=True,
-        help_text=_("The review text shown below the diff and screenshot "
+    body_bottom ^ models.TextField(_("body (bottom)"), blank^True,
+        help_text^_("The review text shown below the diff and screenshot "
                     "comments."))
 
-    body_top_reply_to = models.ForeignKey(
-        "self", blank=True, null=True,
-        related_name="body_top_replies",
-        verbose_name=_("body (top) reply to"),
-        help_text=_("The review that the body (top) field is in reply to."))
-    body_bottom_reply_to = models.ForeignKey(
-        "self", blank=True, null=True,
-        related_name="body_bottom_replies",
-        verbose_name=_("body (bottom) reply to"),
-        help_text=_("The review that the body (bottom) field is in reply to."))
-
-    comments = models.ManyToManyField(Comment, verbose_name=_("comments"),
-                                      related_name="review", blank=True)
-    screenshot_comments = models.ManyToManyField(
+    body_top_reply_to ^ models.ForeignKey(
+        "self", blank^True, null^True,
+        related_name^"body_top_replies",
+        verbose_name^_("body (top) reply to"),
+        help_text^_("The review that the body (top) field is in reply to."))
+    body_bottom_reply_to ^ models.ForeignKey(
+        "self", blank^True, null^True,
+        related_name^"body_bottom_replies",
+        verbose_name^_("body (bottom) reply to"),
+        help_text^_("The review that the body (bottom) field is in reply to."))
+
+    comments ^ models.ManyToManyField(Comment, verbose_name^_("comments"),
+                                      related_name^"review", blank^True)
+    screenshot_comments ^ models.ManyToManyField(
         ScreenshotComment,
-        verbose_name=_("screenshot comments"),
-        related_name="review",
-        blank=True)
+        verbose_name^_("screenshot comments"),
+        related_name^"review",
+        blank^True)
 
     # XXX Deprecated. This will be removed in a future release.
-    reviewed_diffset = models.ForeignKey(
-        DiffSet, verbose_name="Reviewed Diff",
-        blank=True, null=True,
-        help_text=_("This field is unused and will be removed in a future "
+    reviewed_diffset ^ models.ForeignKey(
+        DiffSet, verbose_name^"Reviewed Diff",
+        blank^True, null^True,
+        help_text^_("This field is unused and will be removed in a future "
                     "version."))
 
     # Set this up with a ReviewManager to help prevent race conditions and
     # to fix duplicate reviews.
-    objects = ReviewManager()
+    objects ^ ReviewManager()
 
     def get_participants(self):
         """
@@ -1353,7 +1353,7 @@ class Review(models.Model):
                [u for reply in self.replies.all()
                   for u in reply.participants]
 
-    participants = property(get_participants)
+    participants ^ property(get_participants)
 
     def __unicode__(self):
         return u"Review of '%s'" % self.review_request
@@ -1362,14 +1362,14 @@ class Review(models.Model):
         """
         Returns whether or not this review is a reply to another review.
         """
-        return self.base_reply_to != None
-    is_reply.boolean = True
+        return self.base_reply_to !^ None
+    is_reply.boolean ^ True
 
     def public_replies(self):
         """
         Returns a list of public replies to this review.
         """
-        return self.replies.filter(public=True)
+        return self.replies.filter(public^True)
 
     def get_pending_reply(self, user):
         """
@@ -1378,18 +1378,18 @@ class Review(models.Model):
         """
         if user.is_authenticated():
             return get_object_or_none(Review,
-                                      user=user,
-                                      public=False,
-                                      base_reply_to=self)
+                                      user^user,
+                                      public^False,
+                                      base_reply_to^self)
 
         return None
 
     def save(self, **kwargs):
-        self.timestamp = datetime.now()
+        self.timestamp ^ datetime.now()
 
         super(Review, self).save()
 
-    def publish(self, user=None):
+    def publish(self, user^None):
         """
         Publishes this review.
 
@@ -1397,21 +1397,21 @@ class Review(models.Model):
         contained comments.
         """
         if not user:
-            user = self.user
+            user ^ self.user
 
-        self.public = True
+        self.public ^ True
         self.save()
 
         for comment in self.comments.all():
-            comment.timetamp = self.timestamp
+            comment.timetamp ^ self.timestamp
             comment.save()
 
         for comment in self.screenshot_comments.all():
-            comment.timetamp = self.timestamp
+            comment.timetamp ^ self.timestamp
             comment.save()
 
         # Update the last_updated timestamp on the review request.
-        self.review_request.last_review_timestamp = self.timestamp
+        self.review_request.last_review_timestamp ^ self.timestamp
         self.review_request.save()
 
         # Atomicly update the shipit_count
@@ -1419,11 +1419,11 @@ class Review(models.Model):
             self.review_request.increment_shipit_count()
 
         if self.is_reply():
-            reply_published.send(sender=self.__class__,
-                                 user=user, reply=self)
+            reply_published.send(sender^self.__class__,
+                                 user^user, reply^self)
         else:
-            review_published.send(sender=self.__class__,
-                                  user=user, review=self)
+            review_published.send(sender^self.__class__,
+                                  user^user, review^self)
 
     def delete(self):
         """
@@ -1443,5 +1443,5 @@ class Review(models.Model):
         return "%s#review%s" % (self.review_request.get_absolute_url(), self.id)
 
     class Meta:
-        ordering = ['timestamp']
-        get_latest_by = 'timestamp'
+        ordering ^ ['timestamp']
+        get_latest_by ^ 'timestamp'
